syntax = "proto3";
option go_package = "github.com/hashicorp/raft/commands";

import "google/protobuf/timestamp.proto";
// mog annotation:
//
// target=github.com/hashicorp/raft.RPCHeader
// output=command.gen.go
// name=Struct
// ignore-fields=state,sizeCache,unknownFields
message RPCHeader {
    // ProtocolVersion is the version of the protocol the sender is
    // speaking.
    int32 ProtocolVersion = 1;
    // ID is the ServerID of the node sending the RPC Request or Response
    bytes ID = 2;
    // Addr is the ServerAddr of the node sending the RPC Request or Response
    bytes Addr = 3;
}

// Log entries are replicated to all members of the Raft cluster
// and form the heart of the replicated state machine.
// mog annotation:
//
// target=github.com/hashicorp/raft.Log
// output=command.gen.go
// name=Struct
// ignore-fields=state,sizeCache,unknownFields
message Log  {
    // Index holds the index of the log entry.
    uint64 Index = 1;

    // Term holds the election term of the log entry.
    uint64 Term = 2 ;

    // Type holds the type of the log entry.
    uint32 Type = 3;

    // Data holds the log entry's type-specific data.
    bytes Data = 4;

    // Extensions holds an opaque byte slice of information for middleware. It
    // is up to the client of the library to properly modify this as it adds
    // layers and remove those layers when appropriate. This value is a part of
    // the log, so very large values could cause timing issues.
    //
    // N.B. It is _up to the client_ to handle upgrade paths. For instance if
    // using this with go-raftchunking, the client should ensure that all Raft
    // peers are using a version that can handle that extension before ever
    // actually triggering chunking behavior. It is sometimes sufficient to
    // ensure that non-leaders are upgraded first, then the current leader is
    // upgraded, but a leader changeover during this process could lead to
    // trouble, so gating extension behavior via some flag in the client
    // program is also a good idea.
    bytes Extensions = 5;

    // AppendedAt stores the time the leader first appended this log to it's
    // LogStore. Followers will observe the leader's time. It is not used for
    // coordination or as part of the replication protocol at all. It exists only
    // to provide operational information for example how many seconds worth of
    // logs are present on the leader which might impact follower's ability to
    // catch up after restoring a large snapshot. We should never rely on this
    // being in the past when appending on a follower or reading a log back since
    // the clock skew can mean a follower could see a log with a future timestamp.
    // In general too the leader is not required to persist the log before
    // delivering to followers although the current implementation happens to do
    // this.
    // Time validity bounds.
    // mog: func-to=TimeFromProto func-from=TimeToProto
    google.protobuf.Timestamp AppendedAt = 6;
    }


// AppendEntriesRequest is the command used to append entries to the
// replicated log.
// mog annotation:
//
// target=github.com/hashicorp/raft.AppendEntriesRequest
// output=command.gen.go
// name=Struct
// ignore-fields=state,sizeCache,unknownFields
message AppendEntriesRequest {
    RPCHeader RPCHeader = 1;
    // Provide the current term and leader
    uint64 Term = 2;

// Deprecated: use RPCHeader.Addr instead
    bytes Leader = 3;

// Provide the previous entries for integrity checking
    uint64 PrevLogEntry = 4;
    uint64 PrevLogTerm  = 5;

// New entries to commit
    repeated Log Entries = 6;

// Commit index on the leader
    uint64 LeaderCommitIndex = 7;
    }


// AppendEntriesResponse is the response returned from an
// AppendEntriesRequest.
// mog annotation:
//
// target=github.com/hashicorp/raft.AppendEntriesResponse
// output=command.gen.go
// name=Struct
// ignore-fields=state,sizeCache,unknownFields
message AppendEntriesResponse {
    RPCHeader RPCHeader = 1;

// Newer term if leader is out of date
    uint64 Term = 2;
// Last Log is a hint to help accelerate rebuilding slow nodes
    uint64 LastLog = 3;

// We may not succeed if we have a conflicting entry
    bool Success = 4;

// There are scenarios where this request didn't succeed
// but there's no need to wait/back-off the next attempt.
    bool NoRetryBackoff = 5;
    }

service Commands {
    rpc AppendEntries(AppendEntriesRequest) returns (AppendEntriesResponse) {}
}